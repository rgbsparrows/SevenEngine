# SevenEngine的渲染模块(1) - 同步机制
* 在游戏引擎的设计中，渲染模块设计的好坏与否会对性能，以及扩展性产生一个较大的影响，在这里我们对SevenEngine的渲染模块的设计进行一个粗略的叙述，但具体的思考过程就不在这里展示了
* 渲染模块的执行流程
    * 在一帧的渲染中，以FrameResource为核心，逻辑线程，渲染线程，以及GPU轮流对同一个FrameResource进行操作，以得到最终的结果
    * 为了避免不必要的同步操作，我们对FrameResource进行内容分层，并且确保逻辑线程，渲染县城，GPU只能访问到其中的一部分内容，同时在明确这部分内容不会再被继续访问时，标识相应的线程可以停止相应的阻塞
        * 具体的分层设计中，我们将FrameResource分为了存在交叉的两部分内容
            * 会被渲染线程和逻辑线程所访问到的数据：数据(Game_Render)
            * 会被渲染线程和GPU访问到的数据：数据(Render_GPU)
        * 其中数据(Game_Render)的访问顺序是这样
            * 步骤1 游戏线程请求FrameResource
            * 步骤2 由游戏线程进行访问，期间可能会进行填充数据等操作
            * 步骤3 游戏线程访问结束，渲染线程可以开始
            * 步骤4 由逻辑线程进行访问，包括数据填充或其他操作
            * 步骤5 逻辑线程访问结束，逻辑线程可以重新请求到当前的FrameResource
        * 数据(Render_GPU)的访问顺序基本一致
            * 步骤1 逻辑线程请求FrameResource 
                * 在这里的FrameResource中，包含GPU资源
            * 步骤2 由逻辑线程进行访问，进行数据填充，更新等操作，包括GPU资源的创建和释放
            * 步骤3 逻辑线程访问结束
            * 步骤4 GPU执行任务
            * 步骤5 GPU执行到相应的Fence标识，使得渲染线程知晓FrameResource可以被重用
        * 其中，RenderResource还会以这样的形式进行细化
            * 游戏线程有机会访问到的部分
                * 这部分数据通常以代理的形式存在，一般会由每个游戏线程中的实体对应FrameResource中的一个或多个代理，并且允许游戏线程直接对渲染线程进行更新
            * 逻辑线程会访问到的部分
                * 理论上来说，其实整个FrameResource中的几乎所有内容，都可以被逻辑线程来访问到，其通过对逻辑线程所持有的代理来收集数据，在渲染线程中进行若干操作，并最终将所需要的GPU资源创建，GPU任务提交，达成渲染操作
            * GPU会访问到的部分
                * GPU会访问到的部分其实很好区分出来，因为GPU资源都会有着其特定的类型，所以就使得在编写相应的代码时，自然而然的就将其区分开来
* 渲染线程的结构
    * 由渲染模块直接持有全部的FrameResource，并且在上述所描述的步骤中，来变更当前的FrameResource
    * 辅助各个线程及GPU同步的对象及Fence不属于FrameResource的一部分，而是直接由渲染模块接管，将其从FrameResource中剥离出来
* 开发步骤
    * 完成渲染线程的同步操作的设计与实现 -- 已实现
    * 引入IMGUI库，同时在渲染模块中完成UI的渲染操作，以及对UI库的重新封装（只做简单封装即可）
    * 完成对RenderGraph的定义与设计
        * 管线的执行流程
        * 借着这个机会深入学习下UE的RenderGraph结构
