# 编码规范
* 第三方库及内容的使用
    * 不直接使用第三方库，一面出乎意料的宏所造成的影响，同时也避免了不一致的代码风格，如果需要使用第三方库，那么应该加以封装和隔离
        * 尤其针对win32api，其函数命名风格与se相近，且其中有大量的宏，一不小心引擎中的某些函数就会被改名
    * 鼓励使用cpp标准库，以及c++17,20的新内容
    * 鼓励使用sal注释来进行代码约束与检查
* 语言相关的内容
    * 引擎中不应该有任何异常相关的内容，所以所有函数都应该注明noexcept，以便于生成更良好的产物
    * 不允许通过宏定义常亮，宏的作用应该体现在生成，拼接处新的代码上，或是对一些复杂的声明等，尽可能用constexpr变量和constexpr函数来代替其作用
* 代码设计规范
    * 除了表示程序本身的类，以及全局的manager类外，所有的类都不应该借助TAsSingleton实现单例模式，哪怕其在逻辑上只有一个实例。这样可以避免过多的单例所造成的过度解耦，使得代码与代码之间缺少了本应有的逻辑关系
* 代码文件规范
    * 每个代码文件的末尾应该保留有一个空行，这样在git上好看一些
    * #pragma once应该在第一行，而后紧随一空行，再而后跟随其他include文件
    * 标准库及其他第三方库的include应当在引擎中头文件的include之后
    * 代码文件的编码格式应该为UTF8-BOM当代码中没有出现非ascii字符时，这条规则可以暂时被忽略，但是当出现非ascii字符时，必须遵守这条规则
* 命名规范
    * 接口类以I打头，且以__interface声明，而非class或struct，这样可以提高代码的可读性，同时也避免了不必要的虚表生成
    * 模板类以T打头，表示template
    * 用户扩展且继承自UObject的类以U打头，其支持一些基础的反射功能，并以此为基础，支持用户通过文本的方式进行配置
    * UI类以SUI开头
    * 其他的类以S打头，表示Seven
    * concept以C打头，表示concept
    * 枚举以E打头，表示enum
    * 不允许出现全局对象，但允许有单例对象
    * 名称空间没有前缀
    * concept，类及名称空间，全局变量，concept的命名规范除前缀外，其余内容遵守帕斯卡命名法(eg: CModuleClass, SWindowManager, namespace WindowsPlatformApiWarp_Impl, namespace Locale)
    * 函数名的命名规范遵循帕斯卡命名法(eg: ConvertStringToWstring)
    * 数据成员统一以m打头，后面的内容与帕斯卡命名法一致(eg: mModuleInfos)
    * 函数参数以_打头，而后遵守驼峰命名法(eg: _moduleName)
    * 宏的命名全部大写，单词与单词之间以下划线分割，对于辅助其他宏的编写，充当内部实现的的宏，应该在此基础上，以两个下划线'__'为前导(eg: #define COMMENT(...) #define __MAKE_STR(quote) #quote)
* 对单例类，全部成员函数为静态函数的结构体，以及名称空间在使用上的规范
    * 单例类：全局仅存在一个，且在逻辑上并不从属于任何东西的类，并且其能表达某种实体概念，其应该只在各种manager，以及表达程序本体的类中使用，例如ZModuleManger，ZEngineLoop等
    * 全部成员函数为静态函数的结构体：用于表示一系列静态函数和编译期常量的集合，且这些函数都属于相同的范畴，具有相似的内容或共同来源于某个地方，则通常会对其使用结构体进行封装
    * 名称空间：用于表示一系列内容的集合，且这些内容属于相同的范畴，例如都属于本地化相关的内容，另外在名称空间中允许包含其他内容，例如其他的自定义类型等
    * 全部成员函数为静态函数的结构体不能被继承或是继承其他内容，并且不能被实例化
* 杂项规范
    * 代码中的所有内容均使用宽字符串，以避免编码相关的问题，如果在输出时需要其他的编码方式，那么再进行相应的转化
    * 宏不应当影响原本的缩进格式
    * 对于所有具有相同含义的字符串，尽可能限制其只出现一次
    * 所有字符串类型的参数传参时统一使用string_view，而不使用wchar_t*或是const std::wstring&等，当最终的函数实现依赖于字符串结尾的空字符时(例如绝大多数的winapi)，重新构造string对象，并进行传参

# 警示
* 避免滥用模板，造成毫无节制的代码膨胀，尽可能将大部分实现用非模板的方式编写，而模板则可以用做最后的外层接口封装，除非真的有必要所有实现都使用模板，另外需要严谨的设计模板参数，避免几乎完全一致的逻辑会实例化出多份实现