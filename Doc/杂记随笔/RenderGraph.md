* 在材质中只存储各种材质参数的生成方式，以及材质参数包，由管线来控制Shader的实际生成，而非由材质来控制Shader的生成，因为管线是多变的
* RenderGraph
    * x
        * RenderGraph本身是否需要时可控的？
        * 本来的想法是RenderGraph是完全不可控的，只能够通过修改与调整其中的RenderPass来间接的操纵RenderGraph的行为。这么浓应该没啥问题
        * 有一个不太舒服的点是要在头文件里做很多事情，要不然的话就不能用模板，先凑合写吧
    * 执行
        * Init
            * 首先验证RenderGraph中无环
            * 将RenderPass中的子Pass拆开，作为其后继节点存在所有原本依赖于母RenderPass的Pass会转而依赖所有子Pass
            * 剔除RenderGraph中不必要的杂边，例如C同时依赖AB，且B依赖A，那么边AC可以被移除
            * 如果任意节点的出度为1，那么将其与其后继节点合并
            * 我们称经过上述步骤的有向无环图为简单图
            * 这时，其中可能存在部分的非GPU节点，也即无需CommandList来执行指令的节点，做单独标识
                * 对于无需Device等的节点，可以不特殊处理，因为不会造成特殊开销
            * 然后是分组，做多线程的辅助工作
                * 首先进行拓扑排序，可以正常存储，然后逐个Init即可
            * 多线程时可能需要注意，部分子线程的数量可能是不确定的，这个会麻烦很多
                * 影响什么？线程数量，
                * 对于这种情况，如果拆开的话，形态上一定是一个节点突然开花，而后又收拢
                * 但带来的一个新问题是，如果这个RenderPass还有进一步的嵌套呢？每个子进程会执行若干个RenderPass，例如，某种针对阴影贴图的后处理。
                    * 这个能否限制，拒绝其如此执行？或许可以
                * 不过这样也带来了新的接口样式
* 再对名称做个定义
    * RenderGraph：一套完整的渲染管线
    * RenderPass：RenderGraph的组成构建，表示一个渲染过程
    * RenderPackage：将RenderGraph化简后，一般由若干个可以在同一个CommandList上执行且无需终端提交的RenderPass所构成的
* 如果我们把接口样式做个调整呢？我们把要渲染什么再向后挪动
    * 现在的RenderPass中可能有这样的分类
        * 普通，单出的呢RenderPass，例如后处理
        * 包含子Pass的RenderPass，例如对前项/延迟渲染的整合Pass
        * 多进程Pass，例如对常规的场景绘制，阴影绘制等Pass，需要多线程以分发任务，提高效率
        * 这些Pass中，其是否存在不同的渲染接口？
            * 或许可以用这样的方式来尝试统一
                * 获取是否是无命令节点，以进行节点剔除
                * 获取是否是并行RenderPass
                * 在PreRender之后，获取其请求的线程数量？然后分发
                * 那么对于RenderPass的Render函数，也就相当于追加了对应的ThreadIndex参数
            * 上面这些操作，是否可以缩减为获取请求的线程数量？而且这样的话也更可控一些
            * 另外对于这种东西来说，可能会需要前置Pass
            * 如果存在前置Pass的话，是否有可能还需要后置Pass，这个能不能想办法融合到子Pass的概念里？
    * RenderGraph具体会以什么样的方式来执行
        * 原则上肯定是尽量使用无锁编程
        * 过程中有两个主要的任务
            * 主渲染线程通过CommandQueue执行CommandList
            * 从渲染线程分发RenderPackage
        * 如果按照之前设想的，每个RenderPackage中包含一个AtomicFlag/Bool，标识当前事件完成
        * 当一个线程完成其所执行的任务后，这个线程与其他线程无异
        * 当执行完毕相应RenderPackage后，应当吧相应的AtomicFlag置为真
        * 如何获取可执行的RenderPackage
            * 逻辑上的话，应当是每次获取到新的AtomicFlag更新后，更新当前可以被访问的RenerPass
            * 这个操作最好是由各个子渲染线程来执行，并不希望在主线程进行轮询一类的操作
                * 可以这样做
                    * 先不考虑CommandQueue的执行
                    * 在完成初始化操作后，将简化过的RenderPackage进行拓扑排序后放入数组？
                    * 创建待执行数组，生成两个AtomicSize_t，分别表示当前数组长度与尚未执行的元素位置//PendingRenderPackageList
                        * 每帧初始，将所有入度为0的RenderPackage放置在PendingRenderPackageList中
                    * 对每个RenderGraph的循环执行，所以说这个线程，可能需要独立于RenderGraph存在，可以这样，做成简化的线程池的模式，每次压入RenderGraph时，开始一轮执行
                    * 每次，一个RednerThread访问尚未执行的元素位置，进行后自加，并获取对应的值，将其作为当前需要执行的RenderPackage
                        * 现在的假设是RenderThread与一个COmmandList相绑定
                        * 这样的话RenderThread实际上每次执行完毕相关任务后，应该都需要与其间接关联的其他任务进行组团的等待，这个等待实际上会发生么
                            * 会发生，并且没必要
                            * 如果我们每次当任务执行完毕后，都直接将命令提交到CommandQueue呢？
                                * 代价是提交成本一定程度上会增大
                                * 可能会潜在的破坏GPU层面的并行，如果说GPU会选择同时执行来自不同CommandList的不同命令的话
                            * 感谢群聊"巨神级技美图形交流群"中"孤岛喂鸡"大佬的提示，可以通过对RDI模块进行如下改进，来避免上述情况，进一步提高运行效率。
                                * 将Allocator与CommandList拆分开来，其中，CommandAllocator与线程对应，而COmmandList则可以直接放置在池中，随用随取。
                                * 更大胆一点，我们可以将CommandList与RenderPackage直接相互绑定
                                * 而后，当执行完相应的Package时，将CommandList直接丢回相应的数组中
                                * 当检测到所有的Package执行结束后，由主线程对所有的CommandList按照先前拓扑排序的结果进行调用
                                * 另外如果在现在这种情况下，剔除Render
                                * 这样的话有一个麻烦事，资源的状态，就不能保存在资源上了么？应该是不能
                                    * 现在设想这样的情况
                                        * 存在两个线程，在RenderGraph中，是分散的两个RenderPass，其有依赖关系，一个在向RT上绘制，而另一个则将RT作为SRV使用，两个Pass中，资源明显具备有不同的状态，需要进行切换
                                    * DX提供了资源状态的隐式转换，或许可以不用多虑
                            * 别的还有什么设计项？
                                * 并行RenderPass的设计
                                * RenderPackage是否还有必要存在
                                    * 有必要，通常耗时较久的RenderPass应当为并行RenderPass，无法被合并，而其余的RenderPass大多较为短小，合并后可以缩减提交耗时
                                    * 引来的问题是又把资源的状态管理给提出来了如果可能的话，或许还是最好保证RenderPass结束时，资源的状态为Common？但这样的话未必合理，不过可能也还好
                                * 还有一点，暂时只考虑了GPU任务执行的并行化，其中还有数据准备，可能也会需要做并行化处理
                                    * 例如？
                                        * 似乎主要是以裁剪为主
                                    * 这个可以用的时候再说，可以走之前想的套路
                                * 多线程RenderPass先不考虑，到时候先都按单线程来写试试
                            * 情况可能还有更复杂一些的部分
                                * 对于部分并行CommandList，其可能会还需要特殊类型的Allocator
                                * 所以怎么搞？把Allocator的管理权限首先应该是需要下放到
                                * 这部分先不考虑，回归到最初始，简单的情况。
                                * 要不要把依次执行得逻辑给拿回来？
                                    * 用的时候再说