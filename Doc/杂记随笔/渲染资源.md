* PipelineState
    * 以一个完整的DC为标准，尽量将各种渲染状态缩减至一个Shader内，主要是PipelineState与RootSignature
    * 可能还需要存储Buffer与相应的一些对应关系
    * 这两个里面都包括什么，有哪些可能是需要根据渲染的物体而进行调整的，是否需要储存一些额外的信息
    * IRDIInputLayout
        * 可能会根据不同Mesh的数据标识不同而发生变更，例如模型a以float标识法线数据，而模型b以half16标识法线数据，这个可以设置为全局状态
        * Inputlayout除了数据标识外，不会随着模型或
    * ERDIPrimitiveTopologyType
        * 根据是否会启用曲面细分而定，或许也会和MeshShader之间产生部分关联，但或许可以略过
    * mDepthStencilFormat
        * 可以作为管线/全局控制
    * RenderTarget
        * 构建RDG时会作为管线参数的一部分传入，从而在构建PipelineState时区分，所以这想或许也可以作为ShaderId的一部分
    * Shader与PSO的缓存
    * 渲染时的两种可能
        * 每个模型使用Material中相匹配的Shader来渲染
            * 有什么需要变更的
                * 如上即可，应该没什么需要变更的
        * 每个模型使用统一的Shader来渲染
            * 有什么需要变更的
                * 如上
    * 所以暂时来说，可能会发生动态修改的东西只有DsBuffer的格式
        * 另外还有一点的是，Shader虽然被Material所占有，但实际上是由管线所控制创建的，所以上面所述的这些或许都不太需要进行相应的一些变更。
* Mesh -- ok、
    * 暂时来看可能需要的只是IndexBuffer与VertexBuffer
    * 有时间的话可以再补充像是包围盒之类的属性
    * 接下来考虑语义部分，UE中语义是靠一个顶点工厂的概念来标识的，其中的核心是一套枚举，并以此来间接说明VertexBuffer的构成，在这里，我们直接将VertexBuffer拆解，然后存为一套Flag即可
    * 然后我们还需要构建语义信息，每个语义的名称，大小，格式，这部分数据可能只有PipelineState在构建Shader时可能会用到，所以或许可以直接略过
* 参数包
    * Shader不能储存参数，只有材质可以、
    * 但Shader可能需要储存大致的参数位置
    * 常规的Shader与需要材质的Shader应该具有相同或类似的结构，尽量不要存在差异
* 参数的生命周期

* Shader的使用
    * Shader存在这么两种使用情况
        * 配合材质的使用情况，本身不构成独立Shader
        * 独立作为Shader的使用情况
    * 变体
        * 会有由宏所控制生成的若干变体
        * 材质内会有若干静态开关
    * 使用
        * 与管线相关
        * 与材质相关
            * 不管是上面所描述的哪种Shader，都希望只指定宏与Shader本身，其他不希望制定，组合最好由管线来进行
    * Shader确定之后再考虑

* 强调一点，在渲染线程中，可以跳脱RenderProxy之外，独立的使用与占有原始资源，RenderProxy只在与逻辑线程存在某种关系的时候才需要，如果是完全独立的，那么直接持有原始资源
* 资源应该被Pass所直接持有
* Imgui的绘制应该改成Pass的方式，然后Buffer，PipelineState资源由Pass持有
* 完善Transform -> 完善WorldProxy -> 初步管线 -> RDG
* Component持有的Proxy，这里有些地方期望用ECS之类的架构，所以可能要弄个假的Proxy，类似于Entity
* 也不需要特殊的Proxy，只要保存Index就好，反正也不能让他尤其会访问到其他帧的帧资源

* 既然做到这的话数学库就业需要开始加了
    * SSE指令集就不弄了，要不然内存对齐什么的也很麻烦，就直接正常加减乘除好了
    * 矩阵乘法，矩阵生成
    * 向量乘法，叉乘，点乘

* 所以现在要做什么
    * RenderPass
        * RenderPass本身是私有的，但是部分设置可以作为Public属性传递进来
    * 相对来说可能更完善的Imgui框架
    * 完善数学库
    * 增加各种代理操作，并且融合到Component及Actor的创建当中
    * 一个恰当的世界渲染接口
    * RenderTarget
    * Camera属于世界么？我想是可以不属于的
* 依赖关系与靠外程度
    * RenderPas不依赖任何东西，并且暂时可以直接应用在Imgui的改造上
    * WorldProxy不依赖任何东西，呈现效果需要RenderPass支持，另外WorldProxy与Transform暂时可能还没想好
    * RenderTarget
    * Imgui的世界窗口框架
    * Camera
* RenderPass
    * 需要有什么功能
        * Pass是流水线
            * 输入
            * 输出
            * 设置
            * 依赖
            * 资源
            * 输入要局限住，局限在他需要看到的内容里
                * 对于渲染世界的来说，应该只能看到当前世界
                * 对于渲染Imgui来说，可以看到Imgui
            * 多线程
            * Pass或许可以明确地知道
        * 代码层面除了能靠派生解决的以外还有哪些东西？
            * 不同的Pass大概率会有不同的Config
            * 不同的Pass会请求不同的资源，这些资源可能是可以复用的
            * Pass可能会请求前置Pass的资源
            * Pass可以允许看到其他的Pass
            * 世界绘制或许可以和Imgui分开，做两套RenderPass
            * 这样的话输出也可以直接通过访问RenderPass来实现
            * Setup输入也是世界，是统一的，将其作为初始化一类的东西，其他的设置直接房子啊RenderPass身上，是他的自身固有参数与属性
    * 资源上传
        * 可以观察到有不少资源每帧上传的需求，可以封装下
        * 有每帧上传资源的
            * ConstantBuffer，可能存在的动态贴图
        * 单次上传
            * 贴图
        * UploadReource应当奉行延迟构造，当上传发生时再构造
        * 资源释放等三帧？
            * 立即刷新，立即释放，不用等待
    * RenderPass
        * 资源的标识与构建
        * 资源的共享与访问
        * RenderPass的构建，生成，执行
            * RenderPass过程中应该会涉及到这么几个相关的阶段
            * RenderPass构造
            * RenderGraph构造
            * PreFrame
            * Render
            * Clear
        * 资源获取，应该在PreFrame，RenderGraph构造，都有可能发生
        * Clear时发生资源卸载
    * 所以为了资源的复用，应当在RenderPass上外套一层，作为RenderGraph
    * RenderGraph
        * 资源实际的构建等都是在RenderGraph的某些阶段发生，资源也持有在RenderGraph中，而不是RenderPass，RenderPass中只持有资源的某种代理或指针
    * 逻辑线程与RenderGraph的交互
        * RenderGraph的构建
        * 指定World与RenderGraph
        * RenderGraph的运行时修改
    * 可以把RenderGraph同样当做一种特殊的RenderInfo来处理，同样走刷新机制，如果我们想进一步省略的话，那就需要每次都重新构建一个RenderGraph，如果是依赖刷新机制，那么RenderGraph就会需要一份额外的数据拷贝/描述信息。 另外，RenderGraph中，应当是有可供运行时调节的参数的，这样的话总体就可能有这些相关的变量
        * RenderGraph中，各个RenderPass之间的关系，这个一定会触发RenderGraph的重构
        * RenderGraph与各个RenderPass的各种构建参数，逻辑上的话，其中可能有部分会影响RenderGraph的构造，而另一部分则是每帧获取生成，但应该不多？而且运行时区分两类数据可能会很麻烦
        * 还有一点，就是RenderGraph的参数编辑，这个可能会引发轻微卡顿，但或许，可以接受。
        * 所以，大约是这样的逻辑
            * 在逻辑线程完成RenderGraph与内部Pass的构建，参数指定
            * 传递刷新RenderGraph命令到渲染线程中，在渲染线程循环的早期阶段完成RenderGraph构造。
            * 正常的绘制工作
            * 如果发生参数编辑与修改，那么就重新传递刷新RenderGraph命令
            * 如何降低复杂度，按照暂时的逻辑，想要完成基础的渲染工作也会需要进行一套复杂的RenderGraph构造，为了降低这方面的复杂度，继承/函数
                * 首先是想想RenderGraph是否会有通用的储存格式？我想是有的，统一使用一套方案。
                * 那样的话，或许就可以通过函数的方式来完成了。在函数中外城对RenderGraph的构造，并且可以在此基础上进行扩展与更新。