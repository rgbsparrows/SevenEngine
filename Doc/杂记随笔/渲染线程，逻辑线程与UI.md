* 下一步需要构建的是主要是渲染线程，但在编写渲染线程的过程中，需要考虑渲染线程与引擎中其他组件的交互手段
* 术语表
    * FrameResource
        * 渲染过程中，每一帧的渲染工作所依赖的资源
    * CommonRenderResources
        * 整个渲染过程中，可以被每一帧共享的资源，不独属于某个FrameResource，例如Texture
    * 逻辑层
        * UI与世界游戏逻辑等
* 渲染线程的整个编写过程中，暂时想到的有下面这几个点都需要进行
    * 渲染线程的执行过程
        * 在执行过程中，遵循这样的逻辑
            * BeginFrame
                * 等待逻辑线程将渲染所需要的数据完整的传输/更新到逻辑线程
                * 等待上一次使用了当前帧缓冲数据的所有GPU任务执行结束，依赖Fence做一次Yield即可
            * CustomEvent
                * 执行由逻辑线程向渲染线程所传输的命令
            * FrameTick
                * 更新各种状态
                * 执行渲染过程，上传资源等常规的渲染操作                    * 提交/更新后续渲染所依赖的GPU资源，例如CB，同时在这一阶段可以选择去释放上一次的对应帧中的相应资源，亦或者是创建新的资源
            * EndFrame
                * 执行一些后期的运行操作，例如窗口的Present等
                * 提交新的GPUFence
                * 通知逻辑线程，当前FrameResource重新变回可用的状态
    * 在这个过程中的注意事项
        * 在FrameTick执行的前后的环境是干净的，不需要进行额外的清理工作
            * 即我再FrameTick中的任何操作，都不应该使得后续的FrameTick需要做额外的工作，才能保证FrameTick的正确执行
        * RenderGraph的执行过程被完全局限在FrameTick中
        * GUI的绘制不属于RenderGraph的一部分，将GUI的绘制直接强耦合在渲染线程中，而不是额外构建一个RenderGraph
            * 既然GUI的绘制不属于RenderGraph的一部分，而是由渲染线程直接管理，那么的话Present之类的处理也可以同样由渲染县城直接进行管理了
            * 这样的话RenderGraph所执行的任务就可以局限到只在一张RT或者是多张RT上进行绘制，其余的操作都不需要考虑

* 这样的话整个渲染线程好写，其中的困难点和卡点主要还是出在各种渲染对象的创建及信息传递交互上，这部分同时在和UI，GamePlay发生交互，并且存在着可能较为复杂多变的情况，例如我之前一直心念的一个Word用两个RenderGraph同时渲染，并且用能左右横拉的两个框来表示窗口的范围
* 如果按照现在GUI完全由渲染线程来控制的方法的话，之前所设想的两个窗口使用不同的RDI来渲染的机制就泡汤了
    * 这个机制重要么，是应该用全局唯一的RDI还是说把RDIFactory局限到全局唯一，如果局限到全局唯一的话RDI那里需要做一些简单的修改
    * RDI这里最大的目标其实还是在那个3d建模上，只有那个是打算去搞一波RDI的部分
    * 感觉还是移除多RDIFactory的机制，只保留其中的一份，这样的话逻辑上应该能简单一些
* 如果RDI转成了全局唯一，那么的话有一些对象的创建或许就有了更大的程序上的自由，例如SwapChain与贴图
    * 如果使用多RDI的机制的话，SwapChain，Texture等对象是无法在渲染线程，或者说RenderGraph以外的地方创建的，因为逻辑层并不知道，当前在用什么来做渲染
* 最终定下的话，RDI资源的创建还是放在渲染线程的主线程来执行，但资源本身由逻辑线程的对象持有，创建事件通过向渲染线程发送命令的机制来进行
* 用于辅助同步操作的Event和Fence是否应该属于FrameResource的一部分，他们标示的实际上应该是当前FrameResource的状态，但对于渲染线程和逻辑线程来说，其实他们都不关心FrameResource是什么状态，他们只关心是否能拿到FrameResource
* 如果从这个角度来讲的话，那么我倾向于将Event也由渲染线程来直接管理
* 这样的话在同步过程中，相关的对象就有这么几个
    * 在BeginFrame_GameThread时阻塞，在EndFrame_RenderThread时重置的event
    * 在BeginFrame_RenderThread时阻塞，在EndFrame_GameThread时重置的event
    * 在BeginFrame_RenderThread时阻塞，在EndFrame_RenderThread时设置的GpuFence
* 我们可以把上面这几个对象放在一起，作为一个Sync对象，或者是干脆就还是单放，单放的话或许能省点事
* 梳理一下开发过程，顺便也深入理解一下重构式开发
    * 第一步的话先完成渲染线程的异步同步操作
        * 可以在逻辑线程，渲染线程正确的完成同步操作，保证对FrameResource的正常操作
        * 在逻辑线程和渲染线程可以正常的访问到正确的FrameResource
        * 能够做到刷新管线的操作
    * 在脱离世界，资源等的情况下，进行一些初步的渲染操作，保证RDI的正确执行
    * 扩充FrameResource，增加IMGUI相关的数据填充，并完成相应的渲染
    * 进行RenderGraph相关的设计，这部分内容的具体事宜放在后续考虑，暂时先以IMGUI的达成作为一个阶段性目标
* 同步过程中的特殊操作
    * 同步过程中较为特殊的点主要有两个
    * 一个是阻塞，直到当前传入的所有GPU任务都执行完毕，对应的逻辑应该是当前逻辑线程所对应的FrameResource在渲染线程，GPU都完全执行完毕
        * 这个里面有一个问题，当前的FrameResource只会在当前的逻辑帧结束后，才会进入渲染阶段，以及相应的执行，所以说如果想要做FrameResource同步，所以或许只能做到等待之前所有帧的任务执行完毕，但似乎主要应用的情况都是去取出GPU的运算结果时，才需要进行这样的操作
        * 那么的话这个情况可能是类似于什么样，可能是说我传入一个Shader来对图片进行修改，然后我又把结果取出来，存到磁盘上，如果是这样的话，我们得怎么弄
            * 如果按照上面的设计的话，我们相当于最多只能等待到上一帧运行结束，没办法将当前帧进行额外的裁断，那么如果我们要做到刚才的操作，应该得怎么做？
            * 感觉上似乎没太多好的办法，整个来看比较gg，那这样的话相当于我们需要放弃掉从GPU资源中回读到内存的功能，不过似乎倒也不是什么特别大的问题，不是不能接受
        * 如果是这样的话，那么这个阻塞还有什么用处，是否需要保留阻塞这个功能
        * 重新思考了下，回读是一个必要的功能，除非完全放弃SevenEngine中进行资源烘焙的功能，不过考虑到难以通过阻塞的方式来进行，那么的话我们可能就需要让这部分内容用类似于异步轮训之类的方式来进行了，代码一定程度上会变得更复杂，但或许可以接受？也可能接受不了，我不太说得准，那大致的逻辑会是什么样，逻辑线程在当前的FrameResource中部署任务，任务的执行结束的标志呢，任务执行结束应该是需要等待到当前的FrameResource被渲染县城第二次重用时，才会开始标识GPU任务的执行结束
        * 整个过程中可能的回调都会有哪些
            * 回调1 逻辑线程会请求去在渲染线程创建资源
            * 回调2 逻辑线程会请求某些任务完全执行完毕后的Notify
        * 这样的话，整个过程中，回调1是比较简单的，直接传数据即可，回调2复杂一些，因为其中存在一个情况，就是是当FrameResource第二次被渲染线程使用时，才能明确标识相应的任务执行完毕，那么的话相当于一个FrameResource中，需要维持两份回调2数据，一份存储上一次的内容，一份存储当前的内容，这样的话感觉整个下来，复杂度太高了
        * 我们能不能直接开放在渲染线程中，进行额外的Fence调用的机制，感觉上可以，这样的话，问题就简化一些了，逻辑上可以这样，我们在执行完某些操作之后，调一波Fence，这样的话来保证GPU一定执行结束了，这样的话全部操作都还是在渲染县城去执行，如果想要方便编写的话，可能一次的回调包会大一些，或者就是拆开来弄，但复杂度会高一些
        * 另外的话其实有一个简单的方式，就是直接开个子进程，然后再子进程中进行相应的计算，这么的话复杂度什么的一瞬间就都没了，比较舒服，代价的话就是对于一些比较简单的操作来说，会变成什么样
        * 重新梳理一下需求
            * 有的时候我们存在预烘焙或是保存之类的功能，这时需要一个回读功能，在这样的情况下，由于现在的FrameResource设计，使得无法比较简单的做到阻塞的功能
            * 这样的话我们通过制定回调的方式，来完成相应的同步功能，但是对于一些可能任务量较大的任务
* 这样的话，我们相当于只提供一个当运行结束时，阻塞等待渲染线程执行结束的同步操作，其余操作全部异步进行
    * 后续的话，我们或许可以提供额外的AdditionCommandQueue，用来做一些其他的辅助计算，但我们还是不期望在逻辑线程去访问渲染对象