* 下一步需要构建的是主要是渲染线程，但在编写渲染线程的过程中，需要考虑渲染线程与引擎中其他组件的交互手段
* 术语表
    * FrameResource
        * 渲染过程中，每一帧的渲染工作所依赖的资源
    * CommonRenderResources
        * 整个渲染过程中，可以被每一帧共享的资源，不独属于某个FrameResource，例如Texture
    * 逻辑层
        * UI与世界游戏逻辑等
* 渲染线程的整个编写过程中，暂时想到的有下面这几个点都需要进行
    * 渲染线程的执行过程
        * 在执行过程中，遵循这样的逻辑
            * BeginFrame
                * 等待逻辑线程将渲染所需要的数据完整的传输/更新到逻辑线程
                * 等待上一次使用了当前帧缓冲数据的所有GPU任务执行结束，依赖Fence做一次Yield即可
            * CustomEvent
                * 执行由逻辑线程向渲染线程所传输的命令
            * FrameTick
                * 更新各种状态
                * 执行渲染过程，上传资源等常规的渲染操作                    * 提交/更新后续渲染所依赖的GPU资源，例如CB，同时在这一阶段可以选择去释放上一次的对应帧中的相应资源，亦或者是创建新的资源
            * EndFrame
                * 执行一些后期的运行操作，例如窗口的Present等
                * 提交新的GPUFence
                * 通知逻辑线程，当前FrameResource重新变回可用的状态
    * 在这个过程中的注意事项
        * 在FrameTick执行的前后的环境是干净的，不需要进行额外的清理工作
            * 即我再FrameTick中的任何操作，都不应该使得后续的FrameTick需要做额外的工作，才能保证FrameTick的正确执行
        * RenderGraph的执行过程被完全局限在FrameTick中
        * GUI的绘制不属于RenderGraph的一部分，将GUI的绘制直接强耦合在渲染线程中，而不是额外构建一个RenderGraph
            * 既然GUI的绘制不属于RenderGraph的一部分，而是由渲染线程直接管理，那么的话Present之类的处理也可以同样由渲染县城直接进行管理了
            * 这样的话RenderGraph所执行的任务就可以局限到只在一张RT或者是多张RT上进行绘制，其余的操作都不需要考虑

* 这样的话整个渲染线程好写，其中的困难点和卡点主要还是出在各种渲染对象的创建及信息传递交互上，这部分同时在和UI，GamePlay发生交互，并且存在着可能较为复杂多变的情况，例如我之前一直心念的一个Word用两个RenderGraph同时渲染，并且用能左右横拉的两个框来表示窗口的范围
* 如果按照现在GUI完全由渲染线程来控制的方法的话，之前所设想的两个窗口使用不同的RDI来渲染的机制就泡汤了
    * 这个机制重要么，是应该用全局唯一的RDI还是说把RDIFactory局限到全局唯一，如果局限到全局唯一的话RDI那里需要做一些简单的修改
    * RDI这里最大的目标其实还是在那个3d建模上，只有那个是打算去搞一波RDI的部分
    * 感觉还是移除多RDIFactory的机制，只保留其中的一份，这样的话逻辑上应该能简单一些
* 如果RDI转成了全局唯一，那么的话有一些对象的创建或许就有了更大的程序上的自由，例如SwapChain与贴图
    * 如果使用多RDI的机制的话，SwapChain，Texture等对象是无法在渲染线程，或者说RenderGraph以外的地方创建的，因为逻辑层并不知道，当前在用什么来做渲染
* 最终定下的话，RDI资源的创建还是放在渲染线程的主线程来执行，但资源本身由逻辑线程的对象持有，创建事件通过向渲染线程发送命令的机制来进行